From e950dc33e03bd0c80a1304660cbe518379237d3b Mon Sep 17 00:00:00 2001
From: Ben Smith-Mannschott <bsmith.occs@gmail.com>
Date: Sat, 15 Oct 2011 17:08:13 +0200
Subject: [PATCH 1/2] CLJ-852: add regression test

---
 test/clojure/test_clojure/metadata.clj |   12 +++++++++++-
 1 file changed, 11 insertions(+), 1 deletion(-)

diff --git a/test/clojure/test_clojure/metadata.clj b/test/clojure/test_clojure/metadata.clj
index 977a5f1..e746767 100644
--- a/test/clojure/test_clojure/metadata.clj
+++ b/test/clojure/test_clojure/metadata.clj
@@ -77,7 +77,17 @@
                  (def quux 1))
                (def-quux)
                #'quux)]
-        (is (nil? (-> v meta :e)))))))
+        (is (nil? (-> v meta :e))))))
+  (testing "IllegalArgumentException should not be thrown"
+    (testing "when defining var whose value is calculated with a primitive fn."
+      (testing "This case fails without a fix for CLJ-852"
+        (is (eval-in-temp-ns
+             (defn foo ^long [^long x] x)
+             (def x (inc (foo 10))))))
+      (testing "This case should pass even without a fix for CLJ-852"
+        (is (eval-in-temp-ns
+             (defn foo ^long [^long x] x)
+             (def x (foo (inc 10)))))))))
 
 (deftest defn-primitive-args
   (testing "Hinting the arg vector of a primitive-taking fn with a non-primitive type should not result in AbstractMethodError when invoked."
-- 
1.7.9.2


From 1765063a7a0640b7fb25190c31af85e40812b532 Mon Sep 17 00:00:00 2001
From: Ben Smith-Mannschott <bsmith.occs@gmail.com>
Date: Sat, 15 Oct 2011 21:55:52 +0200
Subject: [PATCH 2/2] CLJ-852: add special cases for "int" ... "boolean" to tagToClass()

This causes the test to pass.
---
 src/jvm/clojure/lang/Compiler.java |   41 +++++++++++++++++++++++++-----------
 1 file changed, 29 insertions(+), 12 deletions(-)

diff --git a/src/jvm/clojure/lang/Compiler.java b/src/jvm/clojure/lang/Compiler.java
index fd103ba..919076d 100644
--- a/src/jvm/clojure/lang/Compiler.java
+++ b/src/jvm/clojure/lang/Compiler.java
@@ -963,7 +963,8 @@ static public abstract class HostExpr implements Expr, MaybePrimitiveExpr{
 						c = RT.classForName(sym.name);
 						}
 						catch(Exception e){
-							//aargh
+							// aargh
+							// leave c set to null -> return null
 						}
 						}
 					}
@@ -1010,17 +1011,33 @@ static public abstract class HostExpr implements Expr, MaybePrimitiveExpr{
 				else if(sym.name.equals("longs"))
 					c = long[].class;
 				else if(sym.name.equals("floats"))
-						c = float[].class;
-					else if(sym.name.equals("doubles"))
-							c = double[].class;
-						else if(sym.name.equals("chars"))
-								c = char[].class;
-							else if(sym.name.equals("shorts"))
-									c = short[].class;
-								else if(sym.name.equals("bytes"))
-										c = byte[].class;
-									else if(sym.name.equals("booleans"))
-											c = boolean[].class;
+					c = float[].class;
+				else if(sym.name.equals("doubles"))
+					c = double[].class;
+				else if(sym.name.equals("chars"))
+					c = char[].class;
+				else if(sym.name.equals("shorts"))
+					c = short[].class;
+				else if(sym.name.equals("bytes"))
+					c = byte[].class;
+				else if(sym.name.equals("booleans"))
+					c = boolean[].class;
+				else if(sym.name.equals("int"))
+					c = Integer.TYPE;
+				else if(sym.name.equals("long"))
+					c = Long.TYPE;
+				else if(sym.name.equals("float"))
+					c = Float.TYPE;
+				else if(sym.name.equals("double"))
+					c = Double.TYPE;
+				else if(sym.name.equals("char"))
+					c = Character.TYPE;
+				else if(sym.name.equals("short"))
+					c = Short.TYPE;
+				else if(sym.name.equals("byte"))
+					c = Byte.TYPE;
+				else if(sym.name.equals("boolean"))
+					c = Boolean.TYPE;
 				}
 			}
 		if(c != null)
-- 
1.7.9.2

